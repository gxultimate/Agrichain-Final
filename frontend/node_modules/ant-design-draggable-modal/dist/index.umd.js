(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('antd')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react', 'antd'], factory) :
  (global = global || self, factory(global.AntDesignDraggableModal = {}, global.React, global.antd));
}(this, function (exports, React, antd) { 'use strict';

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  var _assign = function __assign() {
    _assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
      }

      return t;
    };

    return _assign.apply(this, arguments);
  };

  var generateUID = function generateUID() {
    var counter = 1;
    var map = new WeakMap();

    var uid = function uid(item, index) {
      if (typeof item === 'number' || typeof item === 'string') {
        return index ? "idx-" + index : "val-" + item;
      }

      if (!map.has(item)) {
        map.set(item, counter++);
        return uid(item);
      }

      return 'uid' + map.get(item);
    };

    return uid;
  };

  var createSource = function createSource(prefix) {
    if (prefix === void 0) {
      prefix = '';
    }

    return {
      value: 1,
      prefix: prefix,
      uid: generateUID()
    };
  };
  var counter = createSource();
  var source = React.createContext(createSource());
  var lastUsed = React.createContext("");
  var getId = function getId(source) {
    return source.value++;
  };
  var getPrefix = function getPrefix(source) {
    return source ? source.prefix : '';
  };

  var __extends = undefined && undefined.__extends || function () {
    var extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return function (d, b) {
      extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  var UID = function (_super) {
    __extends(UID, _super);

    function UID() {
      var _this = _super !== null && _super.apply(this, arguments) || this;

      _this.state = {
        quartz: _this.props.idSource || counter,
        prefix: getPrefix(_this.props.idSource),
        id: getId(_this.props.idSource || counter)
      };

      _this.uid = function (item) {
        return _this.prefixId(_this.state.id + '-' + _this.state.quartz.uid(item));
      };

      return _this;
    }

    UID.prototype.prefixId = function (id) {
      var uid = this.state.prefix + id;
      return String(this.props.name ? this.props.name(uid) : uid);
    };

    UID.prototype.render = function () {
      var children = this.props.children;
      var id = this.state.id;
      return children(this.prefixId(id), this.uid);
    };

    return UID;
  }(React.Component);

  var generateUID$1 = function generateUID(context) {
    var quartz = context || counter;
    var prefix = getPrefix(quartz);
    var id = getId(quartz);
    var uid = prefix + id;

    var gen = function gen(item) {
      return uid + quartz.uid(item);
    };

    return {
      uid: uid,
      gen: gen
    };
  };

  var useUIDState = function useUIDState() {
    if (process.env.NODE_ENV !== "production") {
      if (!('useContext' in React)) {
        throw new Error('Hooks API requires React 16.7+');
      }
    }

    return React.useState(generateUID$1(React.useContext(source)));
  };

  var useUID = function useUID() {
    var uid = useUIDState()[0].uid;
    return uid;
  };

  var DraggableModalContext = React.createContext(null);

  var ResizeHandle = function ResizeHandle(props) {
    return React.createElement("div", _assign({
      className: "ant-design-draggable-modal-resize-handle"
    }, props), React.createElement("div", {
      className: "ant-design-draggable-modal-resize-handle-inner"
    }));
  };

  var useDrag = function useDrag(x, y, onDrag) {
    var _a = React.useState(false),
        dragging = _a[0],
        setDragging = _a[1];

    var _b = React.useState({
      initX: 0,
      initY: 0,
      mouseDownX: 0,
      mouseDownY: 0
    }),
        initialDragState = _b[0],
        setInitialDragState = _b[1];

    var onMouseDown = React.useCallback(function (e) {
      e.preventDefault();
      setInitialDragState({
        initX: x,
        initY: y,
        mouseDownX: e.clientX,
        mouseDownY: e.clientY
      });
      setDragging(true);
    }, [x, y, setDragging, setInitialDragState]);
    React.useEffect(function () {
      var onMouseMove = function onMouseMove(e) {
        if (dragging) {
          var initX = initialDragState.initX,
              mouseDownX = initialDragState.mouseDownX,
              initY = initialDragState.initY,
              mouseDownY = initialDragState.mouseDownY;
          var dx = e.clientX - mouseDownX;
          var dy = e.clientY - mouseDownY;
          var x_1 = initX + dx;
          var y_1 = initY + dy;
          onDrag(x_1, y_1);
        }
      };

      window.addEventListener('mousemove', onMouseMove, {
        passive: true
      });
      return function () {
        return window.removeEventListener('mousemove', onMouseMove);
      };
    }, [initialDragState, dragging, onDrag]);
    React.useEffect(function () {
      var onMouseUp = function onMouseUp() {
        setDragging(false);
      };

      window.addEventListener('mouseup', onMouseUp);
      return function () {
        return window.removeEventListener('mouseup', onMouseUp);
      };
    }, [setDragging]);
    return onMouseDown;
  };

  var usePrevious = function usePrevious(value) {
    var ref = React.useRef(null);
    React.useEffect(function () {
      // @ts-ignore
      ref.current = value;
    });
    return ref.current;
  };

  var useResize = function useResize(x, y, width, height, onResize) {
    var _a = React.useState(false),
        dragging = _a[0],
        setDragging = _a[1];

    var _b = React.useState({
      initX: 0,
      initY: 0,
      initWidth: 0,
      initHeight: 0,
      mouseDownX: 0,
      mouseDownY: 0
    }),
        initialDragState = _b[0],
        setInitialDragState = _b[1];

    var onMouseDown = React.useCallback(function (e) {
      e.preventDefault();
      setInitialDragState({
        initX: x,
        initY: y,
        initWidth: width,
        initHeight: height,
        mouseDownX: e.clientX,
        mouseDownY: e.clientY
      });
      setDragging(true);
    }, [width, height, setDragging, setInitialDragState, x, y]);
    React.useEffect(function () {
      var onMouseMove = function onMouseMove(e) {
        if (dragging) {
          var initX = initialDragState.initX,
              initY = initialDragState.initY,
              initWidth = initialDragState.initWidth,
              mouseDownX = initialDragState.mouseDownX,
              initHeight = initialDragState.initHeight,
              mouseDownY = initialDragState.mouseDownY;
          var dx = e.clientX - mouseDownX;
          var dy = e.clientY - mouseDownY;
          var width_1 = initWidth + dx;
          var height_1 = initHeight + dy;
          return onResize(initX, initY, width_1, height_1);
        }
      };

      window.addEventListener('mousemove', onMouseMove, {
        passive: true
      });
      return function () {
        return window.removeEventListener('mousemove', onMouseMove);
      };
    }, [initialDragState, dragging, onResize]);
    React.useEffect(function () {
      var onMouseUp = function onMouseUp() {
        setDragging(false);
      };

      window.addEventListener('mouseup', onMouseUp);
      return function () {
        return window.removeEventListener('mouseup', onMouseUp);
      };
    }, [setDragging]);
    return onMouseDown;
  };

  var modalStyle = {
    margin: 0,
    paddingBottom: 0,
    pointerEvents: 'auto'
  };
  var headerStyle = {
    cursor: 'move'
  };
  var DraggableModalInner = React.memo(function (props) {
    var dispatch = props.dispatch,
        modalState = props.modalState,
        id = props.id; // Call on mount and unmount.

    React.useEffect(function () {
      dispatch({
        type: 'mount',
        id: id
      });
      return function () {
        return dispatch({
          type: 'unmount',
          id: id
        });
      };
    }, [dispatch, id]); // Bring this to the front if it's been opened with props.

    var visible = props.visible;
    var visiblePrevious = usePrevious(visible);
    React.useEffect(function () {
      if (visible && !visiblePrevious) {
        dispatch({
          type: 'visible',
          id: id
        });
      }
    }, [visible, visiblePrevious, id, dispatch]);
    var zIndex = modalState.zIndex,
        x = modalState.x,
        y = modalState.y,
        width = modalState.width,
        height = modalState.height;
    var style = React.useMemo(function () {
      return _assign({}, modalStyle, {
        top: y,
        left: x,
        height: height
      });
    }, [y, x, height]);
    var onVisibleWithID = React.useCallback(function () {
      return dispatch({
        type: 'visible',
        id: id
      });
    }, [id, dispatch]);
    var onDragWithID = React.useCallback(function (x, y) {
      return dispatch({
        type: 'drag',
        id: id,
        x: x,
        y: y
      });
    }, [dispatch, id]);
    var onResizeWithID = React.useCallback(function (x, y, width, height) {
      return dispatch({
        type: 'resize',
        id: id,
        x: x,
        y: y,
        width: width,
        height: height
      });
    }, [dispatch, id]);
    var onMouseDrag = useDrag(x, y, onDragWithID);
    var onMouseResize = useResize(x, y, width, height, onResizeWithID);
    return React.createElement(antd.Modal, _assign({
      wrapClassName: "ant-design-draggable-modal",
      style: style,
      width: width,
      destroyOnClose: true,
      mask: false,
      maskClosable: false,
      zIndex: zIndex,
      title: React.createElement("div", {
        style: headerStyle,
        onMouseDown: onMouseDrag,
        onClick: onVisibleWithID
      }, "Title")
    }, props), props.children, React.createElement(ResizeHandle, {
      onMouseDown: onMouseResize
    }));
  });
  DraggableModalInner.displayName = 'DraggableModalInner';

  var getWindowSize = function getWindowSize() {
    return {
      width: window.innerWidth || 0,
      height: window.innerHeight || 0
    };
  };

  var clamp = function clamp(min, max, value) {
    return Math.max(min, Math.min(max, value));
  };

  var initialModalsState = {
    maxZIndex: 0,
    windowSize: getWindowSize(),
    modals: {}
  };
  var initialModalState = {
    x: 0,
    y: 0,
    width: 500,
    height: 300,
    zIndex: 0
  };
  var getModalState = function getModalState(state, id) {
    return state.modals[id] || initialModalState;
  };

  var getNextZIndex = function getNextZIndex(state, id) {
    return getModalState(state, id).zIndex === state.maxZIndex ? state.maxZIndex : state.maxZIndex + 1;
  };

  var clampDrag = function clampDrag(windowWidth, windowHeight, x, y, width, height) {
    var maxX = windowWidth - width;
    var maxY = windowHeight - height;
    var clampedX = clamp(0, maxX, x);
    var clampedY = clamp(0, maxY, y);
    return {
      x: clampedX,
      y: clampedY
    };
  };

  var clampResize = function clampResize(windowWidth, windowHeight, x, y, width, height) {
    var maxWidth = windowWidth - x;
    var maxHeight = windowHeight - y;
    var clampedWidth = clamp(200, maxWidth, width);
    var clampedHeight = clamp(200, maxHeight, height);
    return {
      width: clampedWidth,
      height: clampedHeight
    };
  };

  var draggableModalReducer = function draggableModalReducer(state, action) {
    var _a, _b, _c, _d;

    switch (action.type) {
      case 'resize':
        var size = clampResize(state.windowSize.width, state.windowSize.height, action.x, action.y, action.width, action.height);
        return _assign({}, state, {
          maxZIndex: getNextZIndex(state, action.id),
          modals: _assign({}, state.modals, (_a = {}, _a[action.id] = _assign({}, state.modals[action.id], size, {
            zIndex: getNextZIndex(state, action.id)
          }), _a))
        });

      case 'drag':
        return _assign({}, state, {
          maxZIndex: getNextZIndex(state, action.id),
          modals: _assign({}, state.modals, (_b = {}, _b[action.id] = _assign({}, state.modals[action.id], clampDrag(state.windowSize.width, state.windowSize.height, action.x, action.y, state.modals[action.id].width, state.modals[action.id].height), {
            zIndex: getNextZIndex(state, action.id)
          }), _b))
        });

      case 'visible':
        return _assign({}, state, {
          maxZIndex: state.maxZIndex + 1,
          modals: _assign({}, state.modals, (_c = {}, _c[action.id] = _assign({}, initialModalState, state.modals[action.id], {
            zIndex: state.maxZIndex + 1
          }), _c))
        });

      case 'mount':
        return _assign({}, state, {
          maxZIndex: state.maxZIndex + 1,
          modals: _assign({}, state.modals, (_d = {}, _d[action.id] = _assign({}, initialModalState, {
            x: state.windowSize.width / 2 - initialModalState.width / 2,
            y: state.windowSize.height / 2 - initialModalState.height / 2,
            zIndex: state.maxZIndex + 1
          }), _d))
        });

      case 'unmount':
        var modalsClone = _assign({}, state.modals);

        delete modalsClone[action.id];
        return _assign({}, state, {
          modals: modalsClone
        });

      case 'windowResize':
        return _assign({}, state, {
          windowSize: action.size,
          modals: Object.keys(state.modals).reduce(function (modals, id) {
            var _a;

            var position = clampDrag(state.windowSize.width, state.windowSize.height, state.modals[id].x, state.modals[id].y, state.modals[id].width, state.modals[id].height);
            var size = clampResize(state.windowSize.width, state.windowSize.height, position.x, position.y, state.modals[id].width, state.modals[id].height);
            return _assign({}, modals, (_a = {}, _a[id] = _assign({}, state.modals[id], position, size), _a));
          }, {})
        });

      default:
        throw new Error();
    }
  };

  var DraggableModal = function DraggableModal(props) {
    // Get the unique ID of this modal.
    var id = useUID(); // Get modal provider.

    var modalProvider = React.useContext(DraggableModalContext);

    if (!modalProvider) {
      throw new Error('No Provider');
    }

    var dispatch = modalProvider.dispatch,
        state = modalProvider.state;
    var modalState = getModalState(state, id); // We do this so that we don't re-render all modals for every state change.
    // DraggableModalInner uses React.memo, so it only re-renders if
    // if props change (e.g. modalState).

    return React.createElement(DraggableModalInner, _assign({
      id: id,
      dispatch: dispatch,
      modalState: modalState
    }, props));
  };

  var DraggableModalProvider = function DraggableModalProvider(_a) {
    var children = _a.children;

    var _b = React.useReducer(draggableModalReducer, initialModalsState),
        state = _b[0],
        dispatch = _b[1];

    React.useEffect(function () {
      if ((typeof window === "undefined" ? "undefined" : _typeof(window)) !== 'object') {
        return;
      }

      var onResize = function onResize() {
        return dispatch({
          type: 'windowResize',
          size: getWindowSize()
        });
      };

      window.addEventListener('resize', onResize);
      onResize();
      return function () {
        return window.removeEventListener('resize', onResize);
      };
    }, [dispatch]);
    return React.createElement(DraggableModalContext.Provider, {
      value: {
        state: state,
        dispatch: dispatch
      }
    }, children);
  };

  exports.DraggableModal = DraggableModal;
  exports.DraggableModalContext = DraggableModalContext;
  exports.DraggableModalProvider = DraggableModalProvider;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
