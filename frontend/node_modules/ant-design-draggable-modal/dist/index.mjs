import { __assign } from 'tslib';
import { createContext, createElement, useState, useCallback, useEffect, useRef, memo, useMemo, useContext, useReducer } from 'react';
import { useUID } from 'react-uid';
import { Modal } from 'antd';

var DraggableModalContext = createContext(null);

var ResizeHandle = function ResizeHandle(props) {
  return createElement("div", __assign({
    className: "ant-design-draggable-modal-resize-handle"
  }, props), createElement("div", {
    className: "ant-design-draggable-modal-resize-handle-inner"
  }));
};

var useDrag = function useDrag(x, y, onDrag) {
  var _a = useState(false),
      dragging = _a[0],
      setDragging = _a[1];

  var _b = useState({
    initX: 0,
    initY: 0,
    mouseDownX: 0,
    mouseDownY: 0
  }),
      initialDragState = _b[0],
      setInitialDragState = _b[1];

  var onMouseDown = useCallback(function (e) {
    e.preventDefault();
    setInitialDragState({
      initX: x,
      initY: y,
      mouseDownX: e.clientX,
      mouseDownY: e.clientY
    });
    setDragging(true);
  }, [x, y, setDragging, setInitialDragState]);
  useEffect(function () {
    var onMouseMove = function onMouseMove(e) {
      if (dragging) {
        var initX = initialDragState.initX,
            mouseDownX = initialDragState.mouseDownX,
            initY = initialDragState.initY,
            mouseDownY = initialDragState.mouseDownY;
        var dx = e.clientX - mouseDownX;
        var dy = e.clientY - mouseDownY;
        var x_1 = initX + dx;
        var y_1 = initY + dy;
        onDrag(x_1, y_1);
      }
    };

    window.addEventListener('mousemove', onMouseMove, {
      passive: true
    });
    return function () {
      return window.removeEventListener('mousemove', onMouseMove);
    };
  }, [initialDragState, dragging, onDrag]);
  useEffect(function () {
    var onMouseUp = function onMouseUp() {
      setDragging(false);
    };

    window.addEventListener('mouseup', onMouseUp);
    return function () {
      return window.removeEventListener('mouseup', onMouseUp);
    };
  }, [setDragging]);
  return onMouseDown;
};

var usePrevious = function usePrevious(value) {
  var ref = useRef(null);
  useEffect(function () {
    // @ts-ignore
    ref.current = value;
  });
  return ref.current;
};

var useResize = function useResize(x, y, width, height, onResize) {
  var _a = useState(false),
      dragging = _a[0],
      setDragging = _a[1];

  var _b = useState({
    initX: 0,
    initY: 0,
    initWidth: 0,
    initHeight: 0,
    mouseDownX: 0,
    mouseDownY: 0
  }),
      initialDragState = _b[0],
      setInitialDragState = _b[1];

  var onMouseDown = useCallback(function (e) {
    e.preventDefault();
    setInitialDragState({
      initX: x,
      initY: y,
      initWidth: width,
      initHeight: height,
      mouseDownX: e.clientX,
      mouseDownY: e.clientY
    });
    setDragging(true);
  }, [width, height, setDragging, setInitialDragState, x, y]);
  useEffect(function () {
    var onMouseMove = function onMouseMove(e) {
      if (dragging) {
        var initX = initialDragState.initX,
            initY = initialDragState.initY,
            initWidth = initialDragState.initWidth,
            mouseDownX = initialDragState.mouseDownX,
            initHeight = initialDragState.initHeight,
            mouseDownY = initialDragState.mouseDownY;
        var dx = e.clientX - mouseDownX;
        var dy = e.clientY - mouseDownY;
        var width_1 = initWidth + dx;
        var height_1 = initHeight + dy;
        return onResize(initX, initY, width_1, height_1);
      }
    };

    window.addEventListener('mousemove', onMouseMove, {
      passive: true
    });
    return function () {
      return window.removeEventListener('mousemove', onMouseMove);
    };
  }, [initialDragState, dragging, onResize]);
  useEffect(function () {
    var onMouseUp = function onMouseUp() {
      setDragging(false);
    };

    window.addEventListener('mouseup', onMouseUp);
    return function () {
      return window.removeEventListener('mouseup', onMouseUp);
    };
  }, [setDragging]);
  return onMouseDown;
};

var modalStyle = {
  margin: 0,
  paddingBottom: 0,
  pointerEvents: 'auto'
};
var headerStyle = {
  cursor: 'move'
};
var DraggableModalInner = memo(function (props) {
  var dispatch = props.dispatch,
      modalState = props.modalState,
      id = props.id; // Call on mount and unmount.

  useEffect(function () {
    dispatch({
      type: 'mount',
      id: id
    });
    return function () {
      return dispatch({
        type: 'unmount',
        id: id
      });
    };
  }, [dispatch, id]); // Bring this to the front if it's been opened with props.

  var visible = props.visible;
  var visiblePrevious = usePrevious(visible);
  useEffect(function () {
    if (visible && !visiblePrevious) {
      dispatch({
        type: 'visible',
        id: id
      });
    }
  }, [visible, visiblePrevious, id, dispatch]);
  var zIndex = modalState.zIndex,
      x = modalState.x,
      y = modalState.y,
      width = modalState.width,
      height = modalState.height;
  var style = useMemo(function () {
    return __assign({}, modalStyle, {
      top: y,
      left: x,
      height: height
    });
  }, [y, x, height]);
  var onVisibleWithID = useCallback(function () {
    return dispatch({
      type: 'visible',
      id: id
    });
  }, [id, dispatch]);
  var onDragWithID = useCallback(function (x, y) {
    return dispatch({
      type: 'drag',
      id: id,
      x: x,
      y: y
    });
  }, [dispatch, id]);
  var onResizeWithID = useCallback(function (x, y, width, height) {
    return dispatch({
      type: 'resize',
      id: id,
      x: x,
      y: y,
      width: width,
      height: height
    });
  }, [dispatch, id]);
  var onMouseDrag = useDrag(x, y, onDragWithID);
  var onMouseResize = useResize(x, y, width, height, onResizeWithID);
  return createElement(Modal, __assign({
    wrapClassName: "ant-design-draggable-modal",
    style: style,
    width: width,
    destroyOnClose: true,
    mask: false,
    maskClosable: false,
    zIndex: zIndex,
    title: createElement("div", {
      style: headerStyle,
      onMouseDown: onMouseDrag,
      onClick: onVisibleWithID
    }, "Title")
  }, props), props.children, createElement(ResizeHandle, {
    onMouseDown: onMouseResize
  }));
});
DraggableModalInner.displayName = 'DraggableModalInner';

var getWindowSize = function getWindowSize() {
  return {
    width: window.innerWidth || 0,
    height: window.innerHeight || 0
  };
};

var clamp = function clamp(min, max, value) {
  return Math.max(min, Math.min(max, value));
};

var initialModalsState = {
  maxZIndex: 0,
  windowSize: getWindowSize(),
  modals: {}
};
var initialModalState = {
  x: 0,
  y: 0,
  width: 500,
  height: 300,
  zIndex: 0
};
var getModalState = function getModalState(state, id) {
  return state.modals[id] || initialModalState;
};

var getNextZIndex = function getNextZIndex(state, id) {
  return getModalState(state, id).zIndex === state.maxZIndex ? state.maxZIndex : state.maxZIndex + 1;
};

var clampDrag = function clampDrag(windowWidth, windowHeight, x, y, width, height) {
  var maxX = windowWidth - width;
  var maxY = windowHeight - height;
  var clampedX = clamp(0, maxX, x);
  var clampedY = clamp(0, maxY, y);
  return {
    x: clampedX,
    y: clampedY
  };
};

var clampResize = function clampResize(windowWidth, windowHeight, x, y, width, height) {
  var maxWidth = windowWidth - x;
  var maxHeight = windowHeight - y;
  var clampedWidth = clamp(200, maxWidth, width);
  var clampedHeight = clamp(200, maxHeight, height);
  return {
    width: clampedWidth,
    height: clampedHeight
  };
};

var draggableModalReducer = function draggableModalReducer(state, action) {
  var _a, _b, _c, _d;

  switch (action.type) {
    case 'resize':
      var size = clampResize(state.windowSize.width, state.windowSize.height, action.x, action.y, action.width, action.height);
      return __assign({}, state, {
        maxZIndex: getNextZIndex(state, action.id),
        modals: __assign({}, state.modals, (_a = {}, _a[action.id] = __assign({}, state.modals[action.id], size, {
          zIndex: getNextZIndex(state, action.id)
        }), _a))
      });

    case 'drag':
      return __assign({}, state, {
        maxZIndex: getNextZIndex(state, action.id),
        modals: __assign({}, state.modals, (_b = {}, _b[action.id] = __assign({}, state.modals[action.id], clampDrag(state.windowSize.width, state.windowSize.height, action.x, action.y, state.modals[action.id].width, state.modals[action.id].height), {
          zIndex: getNextZIndex(state, action.id)
        }), _b))
      });

    case 'visible':
      return __assign({}, state, {
        maxZIndex: state.maxZIndex + 1,
        modals: __assign({}, state.modals, (_c = {}, _c[action.id] = __assign({}, initialModalState, state.modals[action.id], {
          zIndex: state.maxZIndex + 1
        }), _c))
      });

    case 'mount':
      return __assign({}, state, {
        maxZIndex: state.maxZIndex + 1,
        modals: __assign({}, state.modals, (_d = {}, _d[action.id] = __assign({}, initialModalState, {
          x: state.windowSize.width / 2 - initialModalState.width / 2,
          y: state.windowSize.height / 2 - initialModalState.height / 2,
          zIndex: state.maxZIndex + 1
        }), _d))
      });

    case 'unmount':
      var modalsClone = __assign({}, state.modals);

      delete modalsClone[action.id];
      return __assign({}, state, {
        modals: modalsClone
      });

    case 'windowResize':
      return __assign({}, state, {
        windowSize: action.size,
        modals: Object.keys(state.modals).reduce(function (modals, id) {
          var _a;

          var position = clampDrag(state.windowSize.width, state.windowSize.height, state.modals[id].x, state.modals[id].y, state.modals[id].width, state.modals[id].height);
          var size = clampResize(state.windowSize.width, state.windowSize.height, position.x, position.y, state.modals[id].width, state.modals[id].height);
          return __assign({}, modals, (_a = {}, _a[id] = __assign({}, state.modals[id], position, size), _a));
        }, {})
      });

    default:
      throw new Error();
  }
};

var DraggableModal = function DraggableModal(props) {
  // Get the unique ID of this modal.
  var id = useUID(); // Get modal provider.

  var modalProvider = useContext(DraggableModalContext);

  if (!modalProvider) {
    throw new Error('No Provider');
  }

  var dispatch = modalProvider.dispatch,
      state = modalProvider.state;
  var modalState = getModalState(state, id); // We do this so that we don't re-render all modals for every state change.
  // DraggableModalInner uses React.memo, so it only re-renders if
  // if props change (e.g. modalState).

  return createElement(DraggableModalInner, __assign({
    id: id,
    dispatch: dispatch,
    modalState: modalState
  }, props));
};

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

var DraggableModalProvider = function DraggableModalProvider(_a) {
  var children = _a.children;

  var _b = useReducer(draggableModalReducer, initialModalsState),
      state = _b[0],
      dispatch = _b[1];

  useEffect(function () {
    if ((typeof window === "undefined" ? "undefined" : _typeof(window)) !== 'object') {
      return;
    }

    var onResize = function onResize() {
      return dispatch({
        type: 'windowResize',
        size: getWindowSize()
      });
    };

    window.addEventListener('resize', onResize);
    onResize();
    return function () {
      return window.removeEventListener('resize', onResize);
    };
  }, [dispatch]);
  return createElement(DraggableModalContext.Provider, {
    value: {
      state: state,
      dispatch: dispatch
    }
  }, children);
};

export { DraggableModal, DraggableModalContext, DraggableModalProvider };
